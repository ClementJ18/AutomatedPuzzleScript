\chapter{Conclusion}
\label{ch:conclusion}

In this thesis, we have posed the question of how we could support game designers by leveraging meta-programming techniques. The solution we have proposed to address this question is a system of solution for relating gameplay and code. To implement this system, we have documented PuzzleScript design in order to simplify the creation of our own implementation. This extensive documentation of PuzzleScript's design is the first contribution of our thesis. The document details the the syntax of a PuzzleScript file enabling the creation of a parser. This document also goes thoroughly into the corner cases of PuzzleScript's syntax.

We have used our documentation of PuzzleScript's design to design our own implementation. We have addressed the technical obstacles that we faced when trying to use an existing implementation by leveraging good software engineering practices to make the implementation more maintainable and extensible. The result is the second contribution of our thesis: a general-use tool, ScriptButler, for parsing, running, and analyzing PuzzleScript games.  We have implemented our system of solutions for dynamic analysis into ScriptButler. This implementation allows game developers to get live feedback on the impact of their software changes on gameplay. We have also further extended ScriptButler with IDE support and a debugging interface.

We conclude that relating game code and game mechanics is a valuable way of providing feedback to game designers. We present ScriptButler as a tool for exploring that relation that leverages meta-programming. We believe there is much left to discover and we hope that others can extend the tool to conduct similar research by leveraging PuzzleScript.

\section{Future work}
\label{sec:future_work}
Of course, our work can be extended and improved in several ways. We discuss several directions for future work.

\subsection{Level Solver}
Our tool has been designed with the goal of leveraging meta-programming principles in the context of Automated Game Design (AGD). The approach we have focused on separating from the current AI-based approaches to AGD. However, our tool is not closed to the possibility of combining meta-programming and AI, as such, future work could look into the possibility of adding level solvers as a way of conducting a more thorough gameplay analysis as a complement to our rapid-but-shallow approach.

ScriptButler already exposes the necessary endpoints for an automated player, so the technical requirements for coupling one with the tool are quite low. This would be mostly a research endeavor, understanding how AI can fit in our concept of rapid feedback. Playtesting the entire game on every build would not be viable, so work would have to be done in understanding how the game can be broken down into parts and then executed based on the quality of feedback provided.

\subsection{Procedural Content Generation}
ScripButler transforms PuzzleScript code into Rascal data structures. Future works could extend the tool to make it possible to generate PuzzleScript code from the Rascal data structures. As such, ScriptButler could be used from a PCG perspective to study PuzzleScript. The goal of such a project could be try and generate individual levels or rules that build up into a working game. 

Levels and rules generated by future works could also be evaluated using our existing dynamic analysis module. If a level can be solved trivially, this could detected by the tool. Other trivial solutions might also arise from generating the wide range of content, improving the tool's analysis capabilities.

\subsection{Audio-Visual Research}
Part of a game's quality is how it looks and sound. This a facet of game design that we did not touch upon in this project. However, there is room to apply research in that area to our tool. For instance, some combinations of colors create contrasts that are painful to the eye. What if our tool could detect such an instance and provide a warning.

However, such a project would first have to understand how graphics and sounds interact within game design. With a few lines of code, a plugin could be added to ScriptButler to allow for such analysis.

% \subsection{Defining Fun}

\subsection{Automated Game Design for Serious Games}
Serious games are more complex to design than regular games because they have an educational component\cite{DBLP:conf/dagstuhl/BraadZS15}. PuzzleScript games can potentially be used in an educational context. We have found a game that demonstrates how breath-first search behaves using a PuzzleScript game\cite{puzzlescript-bfs}. It is not completely clear whether this is an effective method of teaching as PuzzleScript games require more intuition than most other games to play. This is one of the weaker future works, but we wanted to introduce it anyways.

% \subsection{Applying to other languages}


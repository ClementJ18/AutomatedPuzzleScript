\subsection{Post Processing}
% not sure what else to explain without getting technical // TODO: Ask Riemer
The post-processing phase aims to make it easier to manipulate game code programmatically and pad the weaknesses of the grammar. During this phase, we annotate the parsed tree with metadata. This metadata can be used by other phases of our tool to provide feedback or create features to support game designers. For instance, our IDE plugin uses object annotations to provide syntax coloring for the game designer. The reason that we annotate the objects rather than providing direct syntax coloring is part of our design decision to decouple frontend and backend. The benefit is that as long as the annotations are not modified, the syntax coloring will remain functional even if the grammar changes.

As we have previously mentioned, the grammar creates a parse tree that is hard for a compiler or game engine to manipulate. This phase help us address those flaws. We traverse the parse tree and map PuzzleScript objects to more efficient data structures. For instance, in our grammar, Sprites are defined as five individual lines. These lines are considered as individual attributes and cannot be accessed by index. In this phase, we access each of the individual lines and transform them into a list that is easier to traverse. In addition, we attach the original object to the new data structure. This approach guarantees that IDEs always have a copy of the original code to display to the game designer. The trade-off of this approach is that our tool takes up more memory space. Finally, this phase also insures that all sections of the game exist, even as empty sections. This is useful in certain instances when the game designer may omit certain sections. In these cases, our AST is still guaranteed to have an attribute for that section that can be accessed for the tool but will return as an empty section.

The result of this section is a data structure representing the entire game and all its components. This data structure is easier to manipulate than the original AST. This phase also provides simple feedback to game designers in the form features such as syntax coloring. We discuss the many uses of the annotations in Section \ref{sec:ide}. We pass the data structures to the static check which is described in the next section.

